<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Field Production Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
    <style>
        .drag-over {
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
        }
        
        .company-pill {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .company-pill .remove-btn {
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
        }
        .company-pill .remove-btn:hover {
            background: rgba(255,255,255,0.5);
        }
        .dropdown-container {
            position: relative;
        }
        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            z-index: 1000;
            max-height: 300px;
            overflow-y: auto;
        }
        .dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #f3f4f6;
        }
        .dropdown-item:hover {
            background: #f9fafb;
        }
        .dropdown-item:last-child {
            border-bottom: none;
        }
        .search-input {
            position: sticky;
            top: 0;
            background: white;
            border-bottom: 1px solid #e5e7eb;
            padding: 12px 16px;
        }
        .toggle-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }
        .toggle-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .edit-button {
            background: transparent;
            color: #3b82f6;
            border: none;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            width: 32px;
            height: 32px;
        }
        .edit-button:hover {
            background: #eff6ff;
            color: #2563eb;
        }
        .chart-title-container {
            text-align: center;
            margin-bottom: 16px;
        }
        .chart-main-title {
            font-size: 20px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 4px;
        }
        .chart-subtitle {
            font-size: 14px;
            color: #6b7280;
            font-weight: 400;
        }
        .chart-container {
            position: relative;
            transition: height 0.3s ease;
        }

        .chart-toggle-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .chart-toggle-btn:hover {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .chart-toggle-btn i {
            color: #6b7280;
            font-size: 14px;
            transition: transform 0.3s ease;
            transform: rotate(0deg);
        }

        /* More specific selectors for Font Awesome SVGs */
        .chart-expanded .chart-toggle-btn i,
        .chart-expanded .chart-toggle-btn svg {
            transform: rotate(180deg) !important;
        }

        /* Also target the SVG path if needed */
        .chart-expanded .chart-toggle-btn i svg,
        .chart-expanded .chart-toggle-btn svg {
            transform: rotate(180deg);
        }

        .chart-canvas-container {
            height: 384px; /* 24rem = 384px */
            transition: height 0.3s ease;
        }

        .chart-expanded .chart-canvas-container {
            height: 868px; /* Double the height */
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-gray-900 mb-8 text-center">Field Production Analysis</h1>
        
        <!-- File Upload Section -->
        <div id="uploadSection" class="space-y-6">
            <!-- Single Upload Area -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">Upload CSV Data Files</h2>
                
                <!-- Expected Files Pills -->
                <div class="flex flex-wrap gap-3 mb-4">
                    <div id="productionPill" class="px-3 py-1 rounded-full text-sm font-medium bg-gray-100 text-gray-600 border border-gray-300">
                        <i class="fas fa-file-csv mr-1"></i>
                        Production Data (field_production_monthly.csv)
                    </div>
                    <div id="licenseePill" class="px-3 py-1 rounded-full text-sm font-medium bg-gray-100 text-gray-600 border border-gray-300">
                        <i class="fas fa-file-csv mr-1"></i>
                        Licensee Data (field_licensee_hst.csv)
                    </div>
                </div>
                
                <!-- Drop Zone -->
                <div id="multiDropZone" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer hover:border-blue-400 transition-colors">
                    <i class="fas fa-upload text-4xl text-gray-400 mb-4"></i>
                    <p class="text-gray-600 text-lg mb-2">Drag and drop CSV files here or click to browse</p>
                    <p class="text-gray-500 text-sm">Supports multiple file upload - drop both files at once</p>
                    <input type="file" id="multiFileInput" accept=".csv" multiple class="hidden">
                </div>
                
                <!-- Status Messages -->
                <div id="uploadStatus" class="mt-4 space-y-2">
                    <!-- Status messages will be inserted here -->
                </div>
            </div>
        </div>
        <!-- Analysis Section -->
        <div id="analysisSection" class="hidden space-y-6">
            <!-- Company Selection -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <div class="space-y-4">
                    <label class="block text-sm font-medium text-gray-700">Select Companies</label>
                    
                    <!-- Selected Companies Display -->
                    <div id="selectedCompaniesDisplay" class="min-h-[50px] p-3 border border-gray-300 rounded-lg bg-gray-50">
                        <div id="selectedCompanies" class="flex flex-wrap items-center gap-2">
                            <button id="toggleDropdown" class="toggle-button">
                                <i class="fas fa-plus"></i>
                                <span>Select Company</span>
                            </button>
                        </div>
                    </div>

                    <!-- Dropdown Container -->
                    <div id="dropdownContainer" class="dropdown-container hidden">
                        <div id="dropdownMenu" class="dropdown-menu">
                            <div class="search-input">
                                <input 
                                    type="text" 
                                    id="companySearch" 
                                    placeholder="Search companies..." 
                                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                                >
                            </div>
                            <div id="companyList"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label for="startDate" class="block text-sm font-medium text-gray-700 mb-2">Start Date</label>
                            <input type="month" id="startDate" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label for="endDate" class="block text-sm font-medium text-gray-700 mb-2">End Date</label>
                            <input type="month" id="endDate" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                    </div>
                    <div>
                        <label for="unitSelect" class="block text-sm font-medium text-gray-700 mb-2">Unit System</label>
                        <select id="unitSelect" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="si-monthly">SI - Monthly</option>
                            <option value="si-daily">SI - Daily</option>
                            <option value="barrels-daily">Barrels - Daily</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Chart Sections -->
            <div class="space-y-6">
                <!-- Oil Equivalent Chart -->
                <div class="bg-white rounded-lg shadow-md p-6 chart-container">
                    <div id="oeChartTitleContainer" class="chart-title-container">
                        <div id="oeChartTitle" class="chart-main-title">Oil Equivalent Production by Field (KOE)</div>
                        <div id="oeChartSubtitle" class="chart-subtitle"></div>
                    </div>
                    <button class="chart-toggle-btn" onclick="window.chartManager.toggleChart('oe')">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                    <div class="chart-canvas-container">
                        <canvas id="oeChart"></canvas>
                    </div>
                </div>

                <!-- Oil Chart -->
                <div class="bg-white rounded-lg shadow-md p-6 chart-container">
                    <div id="oilChartTitleContainer" class="chart-title-container">
                        <div id="oilChartTitle" class="chart-main-title">Oil Production by Field (KCM)</div>
                        <div id="oilChartSubtitle" class="chart-subtitle"></div>
                    </div>
                    <button class="chart-toggle-btn" onclick="window.chartManager.toggleChart('prfPrdOilNetMillSm3')">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                    <div class="chart-canvas-container">
                        <canvas id="oilChart"></canvas>
                    </div>
                </div>

                <!-- Gas Chart -->
                <div class="bg-white rounded-lg shadow-md p-6 chart-container">
                    <div id="gasChartTitleContainer" class="chart-title-container">
                        <div id="gasChartTitle" class="chart-main-title">Gas Production by Field (MCM)</div>
                        <div id="gasChartSubtitle" class="chart-subtitle"></div>
                    </div>
                    <button class="chart-toggle-btn" onclick="window.chartManager.toggleChart('prfPrdGasNetBillSm3')">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                    <div class="chart-canvas-container">
                        <canvas id="gasChart"></canvas>
                    </div>
                </div>

                <!-- NGL Chart -->
                <div class="bg-white rounded-lg shadow-md p-6 chart-container">
                    <div id="nglChartTitleContainer" class="chart-title-container">
                        <div id="nglChartTitle" class="chart-main-title">NGL Production by Field (KCM)</div>
                        <div id="nglChartSubtitle" class="chart-subtitle"></div>
                    </div>
                    <button class="chart-toggle-btn" onclick="window.chartManager.toggleChart('prfPrdNGLNetMillSm3')">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                    <div class="chart-canvas-container">
                        <canvas id="nglChart"></canvas>
                    </div>
                </div>

                <!-- Condensate Chart -->
                <div class="bg-white rounded-lg shadow-md p-6 chart-container">
                    <div id="condensateChartTitleContainer" class="chart-title-container">
                        <div id="condensateChartTitle" class="chart-main-title">Condensate Production by Field (KCM)</div>
                        <div id="condensateChartSubtitle" class="chart-subtitle"></div>
                    </div>
                    <button class="chart-toggle-btn" onclick="window.chartManager.toggleChart('prfPrdCondensateNetMillSm3')">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                    <div class="chart-canvas-container">
                        <canvas id="condensateChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===================================================================
        // CONFIGURATION AND CONSTANTS
        // ===================================================================
        
        const CONFIG = {
            CUBIC_METER_TO_BARRELS: 6.28981,
            CUBIC_METER_TO_CUBIC_FEET: 35.3147,
            RESOURCE_TYPES: [
                { key: 'oe', chartId: 'oeChart', titleId: 'oeChartTitle', subtitleId: 'oeChartSubtitle', name: 'Oil Equivalent' },
                { key: 'prfPrdOilNetMillSm3', chartId: 'oilChart', titleId: 'oilChartTitle', subtitleId: 'oilChartSubtitle', name: 'Oil' },
                { key: 'prfPrdGasNetBillSm3', chartId: 'gasChart', titleId: 'gasChartTitle', subtitleId: 'gasChartSubtitle', name: 'Gas' },
                { key: 'prfPrdNGLNetMillSm3', chartId: 'nglChart', titleId: 'nglChartTitle', subtitleId: 'nglChartSubtitle', name: 'NGL' },
                { key: 'prfPrdCondensateNetMillSm3', chartId: 'condensateChart', titleId: 'condensateChartTitle', subtitleId: 'condensateChartSubtitle', name: 'Condensate' }
            ]
        };

        // ===================================================================
        // UTILITY FUNCTIONS
        // ===================================================================

        // Convert days in month for date calculations
        function getDaysInMonth(year, month) {
            return new Date(year, month, 0).getDate();
        }

        // Parse year/month into Date object
        function parseDate(year, month) {
            const y = parseInt(year);
            const m = parseInt(month) - 1; // JS months are 0-indexed
            return new Date(y, m, 1);
        }

        // Format Date object to YYYY-MM string
        function formatDate(date) {
            return date.toISOString().slice(0, 7);
        }

        // Check if date falls within specified range
        function isDateInRange(date, startDate, endDate) {
            return date >= startDate && date <= endDate;
        }

        // Parse DD.MM.YYYY license date string to Date object
        function parseLicenseDate(dateStr) {
            if (!dateStr || dateStr === '') return null;
            const parts = dateStr.split('.');
            if (parts.length !== 3) return null;
            const day = parseInt(parts[0]);
            const month = parseInt(parts[1]);
            const year = parseInt(parts[2]);
            return new Date(year, month - 1, day);
        }

        // Parse CSV text into array of objects
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] ? values[index].trim() : '';
                });
                data.push(row);
            }
            return data;
        }

        // ===================================================================
        // EVENT BUS CLASS - Inter-class communication system
        // ===================================================================

        class EventBus {
            constructor() {
                this.listeners = new Map();
            }

            // Subscribe to an event with callback function
            on(event, callback) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, []);
                }
                this.listeners.get(event).push(callback);
            }

            // Publish event with optional data payload
            emit(event, data = null) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).forEach(callback => callback(data));
                }
            }

            // Remove event listener
            off(event, callback) {
                if (this.listeners.has(event)) {
                    const callbacks = this.listeners.get(event);
                    const index = callbacks.indexOf(callback);
                    if (index > -1) {
                        callbacks.splice(index, 1);
                    }
                }
            }
        }

        // ===================================================================
        // DATA MANAGER CLASS - Handles data loading, filtering and preprocessing
        // ===================================================================

        class DataManager {
            constructor(eventBus) {
                this.eventBus = eventBus;
                this.rawData = {
                    production: null,
                    licensee: null
                };
                
                // Preprocessed indices for O(1) lookups
                this.indices = {
                    licensesByField: new Map(),        // fieldId -> Map(companyId -> [licenses])
                    productionByField: new Map(),      // fieldId -> Map(monthKey -> productionRow)
                    fieldCompanies: new Map(),         // fieldId -> Set(companyIds)
                    companyFields: new Map(),          // companyId -> Set(fieldIds)
                    activeLicenses: new Map()          // licenseKey -> {isActive, activeMonths}
                };
                
                // Metadata maps for quick lookups
                this.metadata = {
                    fieldNames: new Map(),             // fieldId -> fieldName
                    fieldIds: new Map(),               // fieldName -> fieldId
                    companyNames: new Map(),           // companyId -> companyName
                    companyIds: new Map()              // companyName -> companyId
                };
                
                this.currentDateRange = { startDate: null, endDate: null };
                this.filteredProductionData = [];
            }

            // Load and validate production data
            loadProductionData(data) {
                this.rawData.production = data;
                this.eventBus.emit('dataLoaded', { type: 'production' });
            }

            // Load and validate licensee data
            loadLicenseeData(data) {
                this.rawData.licensee = data;
                this.buildMetadataMaps();
                this.eventBus.emit('dataLoaded', { type: 'licensee' });
            }

            // Build field and company name mapping for quick lookups
            buildMetadataMaps() {
                this.rawData.licensee.forEach(row => {
                    if (row.fldName && row.fldNpdidField) {
                        this.metadata.fieldNames.set(row.fldNpdidField, row.fldName);
                        this.metadata.fieldIds.set(row.fldName, row.fldNpdidField);
                    }
                    if (row.cmpNpdidCompany && row.cmpLongName) {
                        this.metadata.companyNames.set(row.cmpNpdidCompany, row.cmpLongName);
                        this.metadata.companyIds.set(row.cmpLongName, row.cmpNpdidCompany);
                    }
                });
            }

            // Filter production data by date range and cache result
            updateDateRange(startDate, endDate) {
                // Only update if date range actually changed
                if (this.currentDateRange.startDate?.getTime() === startDate.getTime() && 
                    this.currentDateRange.endDate?.getTime() === endDate.getTime()) {
                    return false;
                }

                this.currentDateRange = { startDate, endDate };
                
                // Filter production data once for the date range
                this.filteredProductionData = this.rawData.production.filter(row => {
                    const rowDate = parseDate(row.prfYear, row.prfMonth);
                    return isDateInRange(rowDate, startDate, endDate);
                });

                // Rebuild indices for new date range
                this.preprocessData();
                return true;
            }

            // Build all preprocessed indices for fast O(1) lookups
            preprocessData() {
                this.buildLicenseIndex();
                this.buildProductionIndex();
                this.buildRelationshipMaps();
                this.precomputeLicenseActivity();
            }

            // Build index of licenses by field and company for O(1) lookup
            buildLicenseIndex() {
                this.indices.licensesByField.clear();
                
                this.rawData.licensee.forEach(license => {
                    const fieldId = license.fldNpdidField;
                    const companyId = license.cmpNpdidCompany;
                    
                    if (!fieldId || !companyId) return;
                    
                    if (!this.indices.licensesByField.has(fieldId)) {
                        this.indices.licensesByField.set(fieldId, new Map());
                    }
                    
                    if (!this.indices.licensesByField.get(fieldId).has(companyId)) {
                        this.indices.licensesByField.get(fieldId).set(companyId, []);
                    }
                    
                    this.indices.licensesByField.get(fieldId).get(companyId).push(license);
                });
            }

            // Build index of production data by field and month for O(1) lookup
            buildProductionIndex() {
                this.indices.productionByField.clear();
                
                this.filteredProductionData.forEach(row => {
                    const fieldId = row.prfNpdidInformationCarrier;
                    if (!fieldId) return;
                    
                    const monthKey = formatDate(parseDate(row.prfYear, row.prfMonth));
                    
                    if (!this.indices.productionByField.has(fieldId)) {
                        this.indices.productionByField.set(fieldId, new Map());
                    }
                    
                    this.indices.productionByField.get(fieldId).set(monthKey, row);
                });
            }

            // Build relationship maps for which companies are in which fields
            buildRelationshipMaps() {
                this.indices.fieldCompanies.clear();
                this.indices.companyFields.clear();
                
                this.filteredProductionData.forEach(row => {
                    const fieldId = row.prfNpdidInformationCarrier;
                    if (!fieldId) return;
                    
                    const rowDate = parseDate(row.prfYear, row.prfMonth);
                    const fieldLicenses = this.indices.licensesByField.get(fieldId);
                    
                    if (fieldLicenses) {
                        fieldLicenses.forEach((licenses, companyId) => {
                            // Check if any license is active for this month
                            const hasActiveLicense = licenses.some(license => 
                                this.isLicenseActiveForDate(license, rowDate)
                            );
                            
                            if (hasActiveLicense) {
                                // Add to field->companies mapping
                                if (!this.indices.fieldCompanies.has(fieldId)) {
                                    this.indices.fieldCompanies.set(fieldId, new Set());
                                }
                                this.indices.fieldCompanies.get(fieldId).add(companyId);
                                
                                // Add to company->fields mapping
                                if (!this.indices.companyFields.has(companyId)) {
                                    this.indices.companyFields.set(companyId, new Set());
                                }
                                this.indices.companyFields.get(companyId).add(fieldId);
                            }
                        });
                    }
                });
            }

            // Precompute which licenses are active for the current date range
            precomputeLicenseActivity() {
                this.indices.activeLicenses.clear();
                
                this.rawData.licensee.forEach((license, index) => {
                    const fromDate = parseLicenseDate(license.fldLicenseeFrom) || new Date('1900-01-01');
                    const toDate = parseLicenseDate(license.fldLicenseeTo) || new Date('2099-12-31');
                    
                    const licenseKey = `${index}`;
                    this.indices.activeLicenses.set(licenseKey, {
                        license: license,
                        fromDate: fromDate,
                        toDate: toDate,
                        isActiveInRange: this.currentDateRange.startDate <= toDate && this.currentDateRange.endDate >= fromDate
                    });
                });
            }

            // Check if license is active for specific date (optimized)
            isLicenseActiveForDate(license, targetDate) {
                const fromDate = parseLicenseDate(license.fldLicenseeFrom) || new Date('1900-01-01');
                const toDate = parseLicenseDate(license.fldLicenseeTo) || new Date('2099-12-31');
                return targetDate >= fromDate && targetDate <= toDate;
            }

            // Get licenses for field/company combination (O(1) lookup)
            getLicensesForFieldCompany(fieldId, companyId) {
                return this.indices.licensesByField.get(fieldId)?.get(companyId) || [];
            }

            // Get production data for field/month combination (O(1) lookup)
            getProductionForFieldMonth(fieldId, monthKey) {
                return this.indices.productionByField.get(fieldId)?.get(monthKey);
            }

            // Get all companies with production in current date range
            getCompaniesWithProduction() {
                const companies = new Set();
                this.indices.companyFields.forEach((fields, companyId) => {
                    if (fields.size > 0) {
                        companies.add(companyId);
                    }
                });
                return Array.from(companies);
            }

            // Get field name by ID (O(1) lookup)
            getFieldName(fieldId) {
                return this.metadata.fieldNames.get(fieldId);
            }

            // Get company name by ID (O(1) lookup)
            getCompanyName(companyId) {
                return this.metadata.companyNames.get(companyId);
            }

            // Check if both datasets are loaded
            isDataReady() {
                return this.rawData.production && this.rawData.licensee;
            }
        }

        // ===================================================================
        // EQUITY CALCULATOR CLASS - Handles company equity calculations with caching
        // ===================================================================

        class EquityCalculator {
            constructor(dataManager) {
                this.dataManager = dataManager;
                this.equityCache = new Map(); // fieldId|monthKey|companyId -> equity value
                this.equityMatrix = new Map(); // fieldId -> monthKey -> companyId -> equity
            }

            // Calculate individual license equity share
            calculateLicenseEquity(fldCompanyShare, fldSdfiShare) {
                const companyShare = parseFloat(fldCompanyShare) || 0;
                const sdfiShare = parseFloat(fldSdfiShare) || 100.0;
                return (companyShare / 100) * (sdfiShare / 100);
            }

            // Get company equity in field for specific month (cached O(1) lookup)
            getCompanyEquity(fieldId, monthKey, companyId) {
                const cacheKey = `${fieldId}|${monthKey}|${companyId}`;
                
                if (this.equityCache.has(cacheKey)) {
                    return this.equityCache.get(cacheKey);
                }

                const equity = this.calculateCompanyEquity(fieldId, monthKey, companyId);
                this.equityCache.set(cacheKey, equity);
                return equity;
            }

            // Calculate total company equity in field for specific month
            calculateCompanyEquity(fieldId, monthKey, companyId) {
                const rowDate = new Date(monthKey + '-01');
                const licenses = this.dataManager.getLicensesForFieldCompany(fieldId, companyId);
                
                let totalEquity = 0;
                licenses.forEach(license => {
                    if (this.dataManager.isLicenseActiveForDate(license, rowDate)) {
                        totalEquity += this.calculateLicenseEquity(license.fldCompanyShare, license.fldSdfiShare);
                    }
                });

                return totalEquity;
            }

            // Precompute equity matrix for all field/month/company combinations
            precomputeEquityMatrix(selectedCompanies, months) {
                this.equityMatrix.clear();
                
                selectedCompanies.forEach(companyId => {
                    const companyFields = this.dataManager.indices.companyFields.get(companyId) || new Set();
                    
                    companyFields.forEach(fieldId => {
                        if (!this.equityMatrix.has(fieldId)) {
                            this.equityMatrix.set(fieldId, new Map());
                        }
                        
                        months.forEach(monthKey => {
                            if (!this.equityMatrix.get(fieldId).has(monthKey)) {
                                this.equityMatrix.get(fieldId).set(monthKey, new Map());
                            }
                            
                            const equity = this.getCompanyEquity(fieldId, monthKey, companyId);
                            this.equityMatrix.get(fieldId).get(monthKey).set(companyId, equity);
                        });
                    });
                });
            }

            // Clear equity cache when data changes
            clearCache() {
                this.equityCache.clear();
                this.equityMatrix.clear();
            }

            // Get equity breakdown for tooltip display
            getEquityBreakdown(fieldId, monthKey, selectedCompanies) {
                const breakdown = {};
                let totalSelectedEquity = 0;
                
                selectedCompanies.forEach(companyId => {
                    const equity = this.getCompanyEquity(fieldId, monthKey, companyId);
                    if (equity > 0) {
                        const companyName = this.dataManager.getCompanyName(companyId);
                        breakdown[companyName] = equity;
                        totalSelectedEquity += equity;
                    }
                });
                
                return { breakdown, totalSelectedEquity };
            }
        }

        // ===================================================================
        // PRODUCTION PROCESSOR CLASS - Handles production calculations and unit conversions
        // ===================================================================

        class ProductionProcessor {
            constructor(dataManager, equityCalculator) {
                this.dataManager = dataManager;
                this.equityCalculator = equityCalculator;
            }

            // Convert production values based on unit system
            convertProduction(value, resourceType, unitSystem, year, month) {
                if (unitSystem === 'si-monthly') {
                    return value * 1000;
                }
                
                const daysInMonth = getDaysInMonth(year, month);
                
                if (unitSystem === 'si-daily') {
                    return (value * 1000) / daysInMonth;
                }
                
                if (unitSystem === 'barrels-daily') {
                    if (resourceType === 'prfPrdGasNetBillSm3') {
                        return ((value * 1000) * CONFIG.CUBIC_METER_TO_CUBIC_FEET) / daysInMonth;
                    } else {
                        return ((value * 1000) * CONFIG.CUBIC_METER_TO_BARRELS) / daysInMonth;
                    }
                }
                
                return value;
            }

            // Extract specific resource production from row data
            getResourceProduction(row, resourceType) {
                if (resourceType === 'oe') {
                    return (parseFloat(row.prfPrdOilNetMillSm3) || 0) + 
                           (parseFloat(row.prfPrdGasNetBillSm3) || 0) + 
                           (parseFloat(row.prfPrdNGLNetMillSm3) || 0) + 
                           (parseFloat(row.prfPrdCondensateNetMillSm3) || 0);
                }
                return parseFloat(row[resourceType]) || 0;
            }

            // Process production data for selected companies and generate chart data
            processProductionData(selectedCompanies, unitSystem) {
                const allResourceData = {};
                
                // Initialize data structures for all resource types
                CONFIG.RESOURCE_TYPES.forEach(resourceType => {
                    allResourceData[resourceType.key] = {};
                });

                if (selectedCompanies.length === 0) {
                    // Show total field production when no companies selected
                    this.processTotal(allResourceData, unitSystem);
                } else {
                    // Show company equity-based production
                    this.processEquityBased(allResourceData, selectedCompanies, unitSystem);
                }

                return allResourceData;
            }

            // Process total production data without equity calculations
            processTotal(allResourceData, unitSystem) {
                this.dataManager.filteredProductionData.forEach(row => {
                    const fieldId = row.prfNpdidInformationCarrier;
                    const fieldName = this.dataManager.getFieldName(fieldId);
                    if (!fieldName) return;

                    const rowDate = parseDate(row.prfYear, row.prfMonth);
                    const monthKey = formatDate(rowDate);
                    const year = parseInt(row.prfYear);
                    const month = parseInt(row.prfMonth);

                    CONFIG.RESOURCE_TYPES.forEach(resourceType => {
                        const production = this.getResourceProduction(row, resourceType.key);
                        const convertedProduction = this.convertProduction(production, resourceType.key, unitSystem, year, month);

                        if (convertedProduction > 0) {
                            if (!allResourceData[resourceType.key][fieldName]) {
                                allResourceData[resourceType.key][fieldName] = {};
                            }
                            if (!allResourceData[resourceType.key][fieldName][monthKey]) {
                                allResourceData[resourceType.key][fieldName][monthKey] = 0;
                            }
                            allResourceData[resourceType.key][fieldName][monthKey] += convertedProduction;
                        }
                    });
                });
            }

            // Process equity-based production data for selected companies
            processEquityBased(allResourceData, selectedCompanies, unitSystem) {
                this.dataManager.filteredProductionData.forEach(row => {
                    const fieldId = row.prfNpdidInformationCarrier;
                    const fieldName = this.dataManager.getFieldName(fieldId);
                    if (!fieldName) return;

                    const rowDate = parseDate(row.prfYear, row.prfMonth);
                    const monthKey = formatDate(rowDate);
                    const year = parseInt(row.prfYear);
                    const month = parseInt(row.prfMonth);

                    // Calculate total equity for all selected companies
                    let totalSelectedEquity = 0;
                    selectedCompanies.forEach(companyId => {
                        totalSelectedEquity += this.equityCalculator.getCompanyEquity(fieldId, monthKey, companyId);
                    });

                    if (totalSelectedEquity > 0) {
                        CONFIG.RESOURCE_TYPES.forEach(resourceType => {
                            const production = this.getResourceProduction(row, resourceType.key);
                            const rawProduction = production * totalSelectedEquity;
                            const convertedProduction = this.convertProduction(rawProduction, resourceType.key, unitSystem, year, month);

                            if (convertedProduction > 0) {
                                if (!allResourceData[resourceType.key][fieldName]) {
                                    allResourceData[resourceType.key][fieldName] = {};
                                }
                                if (!allResourceData[resourceType.key][fieldName][monthKey]) {
                                    allResourceData[resourceType.key][fieldName][monthKey] = 0;
                                }
                                allResourceData[resourceType.key][fieldName][monthKey] += convertedProduction;
                            }
                        });
                    }
                });
            }

            // Get unit label for chart axes based on unit system and resource type
            getUnitLabel(resourceType, unitSystem) {
                const unitLabels = {
                    'si-monthly': {
                        'oe': 'kOE', 'prfPrdOilNetMillSm3': 'kCM', 'prfPrdGasNetBillSm3': 'MCM',
                        'prfPrdNGLNetMillSm3': 'kCM', 'prfPrdCondensateNetMillSm3': 'kCM'
                    },
                    'si-daily': {
                        'oe': 'kOE/day', 'prfPrdOilNetMillSm3': 'kCM/day', 'prfPrdGasNetBillSm3': 'MCM/day',
                        'prfPrdNGLNetMillSm3': 'kCM/day', 'prfPrdCondensateNetMillSm3': 'kCM/day'
                    },
                    'barrels-daily': {
                        'oe': 'kBBL/day OE', 'prfPrdOilNetMillSm3': 'kBBL/day', 'prfPrdGasNetBillSm3': 'MCF/day',
                        'prfPrdNGLNetMillSm3': 'kBBL/day', 'prfPrdCondensateNetMillSm3': 'kBBL/day'
                    }
                };
                return unitLabels[unitSystem][resourceType] || '';
            }
        }

        // ===================================================================
        // UI MANAGER CLASS - Handles user interface interactions and company selection
        // ===================================================================

        class UIManager {
            constructor(eventBus, dataManager) {
                this.eventBus = eventBus;
                this.dataManager = dataManager;
                this.selectedCompanies = [];
                this.availableCompanies = [];
                this.filteredCompanies = [];
                this.isDropdownVisible = false;
                
                this.initializeEventListeners();
            }

            // Set up all UI event listeners
            initializeEventListeners() {
                this.eventBus.on('companiesUpdated', (data) => {
                    this.updateAvailableCompanies(data.companies);
                });
            }

            // Initialize the multi-select dropdown functionality
            initializeMultiSelect() {
                const toggleBtn = document.getElementById('toggleDropdown');
                const dropdownContainer = document.getElementById('dropdownContainer');
                const searchInput = document.getElementById('companySearch');

                toggleBtn.addEventListener('click', () => {
                    if (this.isDropdownVisible) {
                        this.hideDropdown();
                    } else {
                        this.showDropdown();
                    }
                });

                searchInput.addEventListener('input', (e) => {
                    this.filterCompanies(e.target.value);
                });

                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#dropdownContainer') && !e.target.closest('#toggleDropdown')) {
                        this.hideDropdown();
                    }
                });
            }

            // Show the company selection dropdown
            showDropdown() {
                const dropdownContainer = document.getElementById('dropdownContainer');
                const searchInput = document.getElementById('companySearch');
                
                dropdownContainer.classList.remove('hidden');
                this.isDropdownVisible = true;
                searchInput.value = '';
                this.filterCompanies('');
                setTimeout(() => searchInput.focus(), 100);
            }

            // Hide the company selection dropdown
            hideDropdown() {
                const dropdownContainer = document.getElementById('dropdownContainer');
                dropdownContainer.classList.add('hidden');
                this.isDropdownVisible = false;
            }

            // Filter companies based on search term
            filterCompanies(searchTerm) {
                this.filteredCompanies = this.availableCompanies.filter(company => 
                    company.name.toLowerCase().includes(searchTerm.toLowerCase())
                );
                this.renderCompanyList();
            }

            // Render the filtered company list with checkboxes
            renderCompanyList() {
                const companyList = document.getElementById('companyList');
                companyList.innerHTML = '';

                this.filteredCompanies.forEach(company => {
                    const isSelected = this.selectedCompanies.some(selected => selected.id === company.id);
                    const item = document.createElement('div');
                    item.className = 'dropdown-item';
                    item.innerHTML = `
                        <input type="checkbox" ${isSelected ? 'checked' : ''} class="w-4 h-4 text-blue-600">
                        <span class="flex-1">${company.name}</span>
                    `;
                    item.addEventListener('click', () => this.toggleCompanySelection(company));
                    companyList.appendChild(item);
                });
            }

            // Toggle company selection state
            toggleCompanySelection(company) {
                const index = this.selectedCompanies.findIndex(selected => selected.id === company.id);
                
                if (index === -1) {
                    this.selectedCompanies.push(company);
                } else {
                    this.selectedCompanies.splice(index, 1);
                }
                
                this.updateSelectedCompaniesDisplay();
                this.renderCompanyList();
                this.eventBus.emit('companiesSelected', { companies: this.selectedCompanies });
            }

            // Remove company from selection
            removeCompanySelection(companyId) {
                const index = this.selectedCompanies.findIndex(company => company.id === companyId);
                if (index !== -1) {
                    this.selectedCompanies.splice(index, 1);
                    this.updateSelectedCompaniesDisplay();
                    this.renderCompanyList();
                    this.eventBus.emit('companiesSelected', { companies: this.selectedCompanies });
                }
            }

            // Update the visual display of selected companies
            updateSelectedCompaniesDisplay() {
                const container = document.getElementById('selectedCompanies');
                container.innerHTML = '';
                
                this.selectedCompanies.forEach((company) => {
                    const pill = document.createElement('div');
                    pill.className = 'company-pill';
                    pill.innerHTML = `
                        <span>${company.name}</span>
                        <div class="remove-btn" onclick="window.uiManager.removeCompanySelection('${company.id}')">
                            <i class="fas fa-times"></i>
                        </div>
                    `;
                    container.appendChild(pill);
                });
                
                const toggleBtn = document.createElement('button');
                toggleBtn.id = 'toggleDropdown';
                if (this.selectedCompanies.length === 0) {
                    toggleBtn.className = 'toggle-button';
                    toggleBtn.innerHTML = '<i class="fas fa-plus"></i><span>Select Company</span>';
                } else {
                    toggleBtn.className = 'edit-button';
                    toggleBtn.innerHTML = '<i class="fas fa-edit"></i>';
                }
                
                container.appendChild(toggleBtn);
                this.initializeMultiSelect();
            }

            // Update available companies list
            updateAvailableCompanies(companyIds) {
                this.availableCompanies = companyIds
                    .map(id => ({ 
                        id, 
                        name: this.dataManager.getCompanyName(id) || `Company ${id}` 
                    }))
                    .sort((a, b) => a.name.localeCompare(b.name));
                
                this.filteredCompanies = [...this.availableCompanies];
                
                // Remove invalid selections
                this.selectedCompanies = this.selectedCompanies.filter(selected => 
                    this.availableCompanies.some(available => available.id === selected.id)
                );
                
                this.updateSelectedCompaniesDisplay();
            }

            // Get currently selected company IDs
            getSelectedCompanyIds() {
                return this.selectedCompanies.map(company => company.id);
            }

            // Get currently selected company names
            getSelectedCompanyNames() {
                return this.selectedCompanies.map(company => company.name);
            }
        }

        // ===================================================================
        // CHART MANAGER CLASS - Handles chart creation, updates and styling
        // ===================================================================

        class ChartManager {
            constructor(eventBus, dataManager, equityCalculator) {
                this.eventBus = eventBus;
                this.dataManager = dataManager;
                this.equityCalculator = equityCalculator;
                this.charts = new Map();
                this.expandedCharts = new Set(); // Track which charts are expanded
            }

            // Toggle chart expanded state
            toggleChart(resourceKey) {
                const chartId = this.getChartIdByResourceKey(resourceKey);
                const chartContainer = document.querySelector(`#${chartId}`).closest('.chart-container');
                const toggleButton = chartContainer.querySelector('.chart-toggle-btn');
                const isExpanded = this.expandedCharts.has(resourceKey);
                
                if (isExpanded) {
                    // Collapse
                    chartContainer.classList.remove('chart-expanded');
                    this.expandedCharts.delete(resourceKey);
                } else {
                    // Expand
                    chartContainer.classList.add('chart-expanded');
                    this.expandedCharts.add(resourceKey);
                }
                
                // Resize chart after animation completes
                setTimeout(() => {
                    const chart = this.charts.get(chartId);
                    if (chart) {
                        chart.resize();
                    }
                }, 300); // Match CSS transition duration
            }

            // Helper function to get chart ID by resource key
            getChartIdByResourceKey(resourceKey) {
                const resourceType = CONFIG.RESOURCE_TYPES.find(type => type.key === resourceKey);
                return resourceType ? resourceType.chartId : null;
            }

            // Generate distinct colors for chart series
            generateColors(count) {
                const colors = [];
                for (let i = 0; i < count; i++) {
                    const hue = (i * 360 / count) % 360;
                    colors.push({
                        line: `hsl(${hue}, 70%, 50%)`,
                        fill: `hsl(${hue}, 70%, 80%)`
                    });
                }
                return colors;
            }

            // Generate chart title based on resource type and unit system
            getChartTitle(resourceName, resourceType, unit) {
                return `${resourceName} Production by Field (${unit})`;
            }

            // Generate chart subtitle based on selected companies
            getChartSubtitle(selectedCompanyNames) {
                if (selectedCompanyNames.length === 0) {
                    return 'Total Field Production';
                } else if (selectedCompanyNames.length === 1) {
                    return selectedCompanyNames[0];
                } else {
                    return selectedCompanyNames.join('  ');
                }
            }

            // Handle single click on legend item (default toggle behavior)
            handleLegendSingleClick(chart, datasetIndex) {
                const meta = chart.getDatasetMeta(datasetIndex);
                meta.hidden = meta.hidden === null ? !chart.data.datasets[datasetIndex].hidden : null;
                chart.update();
            }

            // Handle double-click on legend item (show only this item)
            handleLegendDoubleClick(chart, datasetIndex) {
                const datasets = chart.data.datasets;
                
                // Check if currently showing only the double-clicked item
                const visibleDatasets = datasets.filter((_, index) => {
                    const meta = chart.getDatasetMeta(index);
                    return meta.hidden !== true;
                });
                
                const isShowingOnlyClickedItem = visibleDatasets.length === 1 && 
                                               chart.getDatasetMeta(datasetIndex).hidden !== true;
                
                if (isShowingOnlyClickedItem) {
                    // Show all datasets
                    datasets.forEach((_, index) => {
                        const meta = chart.getDatasetMeta(index);
                        meta.hidden = false;
                    });
                } else {
                    // Hide all except the clicked one
                    datasets.forEach((_, index) => {
                        const meta = chart.getDatasetMeta(index);
                        meta.hidden = index !== datasetIndex;
                    });
                }
                
                chart.update();
            }

            // Create custom tooltip for enhanced data display
            createCustomTooltip(unit, resourceType, selectedCompanies) {
                return {
                    enabled: false,
                    external: (context) => {
                        let tooltipEl = document.getElementById('chartjs-tooltip');
                        if (!tooltipEl) {
                            tooltipEl = document.createElement('div');
                            tooltipEl.id = 'chartjs-tooltip';
                            tooltipEl.style.cssText = `
                                position: absolute; background: rgba(0, 0, 0, 0.9); color: white;
                                padding: 12px 16px; border-radius: 8px; font-size: 13px;
                                pointer-events: none; z-index: 1000; line-height: 1.4; max-width: 300px;
                                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                            `;
                            document.body.appendChild(tooltipEl);
                        }

                        const tooltipModel = context.tooltip;
                        if (tooltipModel.opacity === 0) {
                            tooltipEl.style.opacity = 0;
                            return;
                        }

                        if (tooltipModel.body) {
                            this.renderTooltipContent(tooltipEl, context, unit, resourceType, selectedCompanies);
                        }

                        const position = context.chart.canvas.getBoundingClientRect();
                        tooltipEl.style.opacity = 1;
                        tooltipEl.style.left = position.left + window.pageXOffset + tooltipModel.caretX + 'px';
                        tooltipEl.style.top = position.top + window.pageYOffset + tooltipModel.caretY + 'px';
                    }
                };
            }

            // Render tooltip content with company breakdown
            renderTooltipContent(tooltipEl, context, unit, resourceType, selectedCompanies) {
                const dataPoint = context.tooltip.dataPoints[0];
                const monthLabel = dataPoint.label;
                const fieldName = dataPoint.dataset.label;
                const fieldValue = dataPoint.raw;
                
                // Calculate total for this month
                const chart = context.chart;
                const monthIndex = dataPoint.dataIndex;
                let total = 0;
                chart.data.datasets.forEach(dataset => {
                    total += dataset.data[monthIndex] || 0;
                });

                const date = new Date(monthLabel + '-01');
                const formattedDate = date.toLocaleDateString('en-US', { 
                    month: 'short', 
                    year: 'numeric' 
                });

                let companyBreakdownHtml = '';
                let fieldProductionValue = 0;
                let companyTotalProduction = 0;
                
                // Show company breakdown only if companies are selected
                if (selectedCompanies.length > 0) {
                    const fieldId = this.dataManager.metadata.fieldIds.get(fieldName);
                    
                    if (fieldId) {
                        // Get field production (without equity applied)
                        const productionRow = this.dataManager.getProductionForFieldMonth(fieldId, monthLabel);
                        if (productionRow && this.productionProcessor) {
                            const rawFieldProduction = this.productionProcessor.getResourceProduction(productionRow, resourceType);
                            const year = parseInt(productionRow.prfYear);
                            const month = parseInt(productionRow.prfMonth);
                            const unitSystem = document.getElementById('unitSelect').value;
                            fieldProductionValue = this.productionProcessor.convertProduction(rawFieldProduction, resourceType, unitSystem, year, month);
                        }
                        
                        // Calculate company equity breakdown
                        const { breakdown, totalSelectedEquity } = this.equityCalculator.getEquityBreakdown(
                            fieldId, monthLabel, selectedCompanies
                        );
                        
                        if (totalSelectedEquity > 0) {
                            companyBreakdownHtml = Object.entries(breakdown)
                                .map(([companyName, equity]) => {
                                    const absolutePercentage = (equity * 100).toFixed(4);
                                    return `<div style="margin-top: 4px; font-size: 12px; opacity: 0.9;">${companyName}: ${absolutePercentage}%</div>`;
                                })
                                .join('');
                        }
                        
                        // Calculate total company production across all fields for this month
                        companyTotalProduction = this.calculateCompanyTotalProduction(selectedCompanies, monthLabel, resourceType);
                    }
                }

                const productionLabel = selectedCompanies.length === 0 ? 'Total production' : 'Production share';
                const companyLabel = selectedCompanies.length > 1 ? 'Companies total' : 'Company total';
                const fractionLabel = selectedCompanies.length > 1 ? 'companies total' : 'company total';
                
                // Calculate percentage of company total
                const companyTotalPercentage = companyTotalProduction > 0 ? 
                    ((fieldValue / companyTotalProduction) * 100).toFixed(1) : '0.0';

                let tooltipContent = `
                    <div style="font-weight: bold; margin-bottom: 8px; font-size: 14px;">
                        <strong>${fieldName}</strong> - ${formattedDate}
                    </div>`;

                if (selectedCompanies.length > 0) {
                    tooltipContent += `
                        <div style="margin-bottom: 4px;">Field production: ${fieldProductionValue.toFixed(1)} ${unit}</div>
                        ${companyBreakdownHtml}
                        <div style="margin-top: 8px; margin-bottom: 4px;">${productionLabel}: ${fieldValue.toFixed(1)} ${unit}</div>
                        <div style="margin-bottom: 4px;">${companyLabel}: ${companyTotalProduction.toFixed(1)} ${unit}</div>
                        <div style="margin-bottom: 4px;">${productionLabel} / ${fractionLabel}: ${companyTotalPercentage}%</div>`;
                } else {
                    tooltipContent += `
                        <div style="margin-bottom: 4px;">${productionLabel}: ${fieldValue.toFixed(1)} ${unit}</div>
                        <div style="margin-bottom: 8px;">Monthly total: ${total.toFixed(1)} ${unit}</div>`;
                }

                tooltipEl.innerHTML = tooltipContent;
            }

            // Calculate total company production across all fields for a specific month
            calculateCompanyTotalProduction(selectedCompanies, monthLabel, resourceType) {
                let totalProduction = 0;
                const unitSystem = document.getElementById('unitSelect').value;
                
                if (!this.productionProcessor) return 0;
                
                // Get all unique fields that the selected companies have equity in
                const allCompanyFields = new Set();
                selectedCompanies.forEach(companyId => {
                    const companyFields = this.dataManager.indices.companyFields.get(companyId);
                    if (companyFields) {
                        companyFields.forEach(fieldId => allCompanyFields.add(fieldId));
                    }
                });
                
                // Calculate production for each field
                allCompanyFields.forEach(fieldId => {
                    const productionRow = this.dataManager.getProductionForFieldMonth(fieldId, monthLabel);
                    if (productionRow) {
                        // Calculate total equity for selected companies in this field
                        let totalSelectedEquity = 0;
                        selectedCompanies.forEach(companyId => {
                            totalSelectedEquity += this.equityCalculator.getCompanyEquity(fieldId, monthLabel, companyId);
                        });
                        
                        if (totalSelectedEquity > 0) {
                            const rawProduction = this.productionProcessor.getResourceProduction(productionRow, resourceType);
                            const equityProduction = rawProduction * totalSelectedEquity;
                            const year = parseInt(productionRow.prfYear);
                            const month = parseInt(productionRow.prfMonth);
                            const convertedProduction = this.productionProcessor.convertProduction(equityProduction, resourceType, unitSystem, year, month);
                            totalProduction += convertedProduction;
                        }
                    }
                });
                
                return totalProduction;
            }

            // Create or update a chart with new data
            createChart(chartId, resourceName, unit, labels, datasets, resourceType, selectedCompanies) {
                const canvas = document.getElementById(chartId);
                const ctx = canvas.getContext('2d');
                
                // Ensure canvas takes full container size
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                
                if (this.charts.has(chartId)) {
                    this.charts.get(chartId).destroy();
                }

                // Track clicks for double-click detection
                let clickTimeout = null;
                let lastClickTime = 0;
                let lastClickedIndex = -1;

                const chart = new Chart(ctx, {
                    type: 'line',
                    data: { labels, datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: { display: false },
                            legend: { 
                                display: true, 
                                position: 'top', 
                                labels: { boxWidth: 12 },
                                onClick: (event, legendItem, legend) => {
                                    const currentTime = Date.now();
                                    const timeDiff = currentTime - lastClickTime;
                                    const datasetIndex = legendItem.datasetIndex;
                                    
                                    // Clear any existing timeout
                                    if (clickTimeout) {
                                        clearTimeout(clickTimeout);
                                        clickTimeout = null;
                                    }
                                    
                                    // Check for double-click (within 300ms and same item)
                                    if (timeDiff < 300 && lastClickedIndex === datasetIndex) {
                                        // Double-click detected
                                        this.handleLegendDoubleClick(chart, datasetIndex);
                                    } else {
                                        // Single click - set timeout to handle if no second click comes
                                        clickTimeout = setTimeout(() => {
                                            this.handleLegendSingleClick(chart, datasetIndex);
                                            clickTimeout = null;
                                        }, 300);
                                    }
                                    
                                    lastClickTime = currentTime;
                                    lastClickedIndex = datasetIndex;
                                }
                            },
                            tooltip: this.createCustomTooltip(unit, resourceType, selectedCompanies)
                        },
                        scales: {
                            x: { display: true, title: { display: true, text: 'Month' } },
                            y: { 
                                display: true, 
                                title: { display: true, text: `Production (${unit})` },
                                beginAtZero: true, 
                                stacked: true 
                            }
                        },
                        elements: { line: { tension: 0.1 } },
                        interaction: { mode: 'nearest', intersect: false }
                    }
                });

                this.charts.set(chartId, chart);
            }

            // Update all charts with new production data
            updateCharts(productionData, selectedCompanies, selectedCompanyNames, unitSystem, productionProcessor) {
                // Store reference for use in tooltips
                this.productionProcessor = productionProcessor;
                
                CONFIG.RESOURCE_TYPES.forEach(resourceType => {
                    const fieldData = productionData[resourceType.key];
                    
                    // Sort fields by total production
                    const fieldTotals = {};
                    Object.keys(fieldData).forEach(fieldName => {
                        fieldTotals[fieldName] = Object.values(fieldData[fieldName]).reduce((sum, val) => sum + val, 0);
                    });
                    const sortedFields = Object.keys(fieldData).sort((a, b) => fieldTotals[b] - fieldTotals[a]);

                    // Prepare chart data
                    const allMonths = [...new Set(
                        Object.values(fieldData).flatMap(months => Object.keys(months))
                    )].sort();

                    const colors = this.generateColors(sortedFields.length);
                    const datasets = sortedFields.map((fieldName, index) => ({
                        label: fieldName,
                        data: allMonths.map(month => fieldData[fieldName][month] || 0),
                        borderColor: colors[index].line,
                        backgroundColor: colors[index].fill,
                        fill: true
                    }));

                    const unit = productionProcessor.getUnitLabel(resourceType.key, unitSystem);
                    const chartTitle = this.getChartTitle(resourceType.name, resourceType.key, unit);
                    const chartSubtitle = this.getChartSubtitle(selectedCompanyNames);
                    
                    // Update chart titles
                    document.getElementById(resourceType.titleId).textContent = chartTitle;
                    document.getElementById(resourceType.subtitleId).textContent = chartSubtitle;
                    
                    this.createChart(
                        resourceType.chartId, 
                        resourceType.name, 
                        unit, 
                        allMonths, 
                        datasets, 
                        resourceType.key,
                        selectedCompanies
                    );
                });
            }
        }

        // ===================================================================
        // MAIN APPLICATION CLASS - Orchestrates all components
        // ===================================================================

        class ProductionAnalysisApp {
            constructor() {
                this.eventBus = new EventBus();
                this.dataManager = new DataManager(this.eventBus);
                this.equityCalculator = new EquityCalculator(this.dataManager);
                this.productionProcessor = new ProductionProcessor(this.dataManager, this.equityCalculator);
                this.uiManager = new UIManager(this.eventBus, this.dataManager);
                this.chartManager = new ChartManager(this.eventBus, this.dataManager, this.equityCalculator);
                
                this.setupEventListeners();
                this.initializeFileUploads();
                window.chartManager = this.chartManager;
            }

            // Set up event listeners for inter-component communication
            setupEventListeners() {
                this.eventBus.on('dataLoaded', (data) => {
                    // Check if both datasets are loaded
                    if (this.dataManager.isDataReady()) {
                        this.addStatusMessage('Both datasets loaded successfully! Initializing analysis interface...', 'success');
                        setTimeout(() => {
                            this.onDataReady();
                        }, 1000);
                    }
                });

                this.eventBus.on('companiesSelected', (data) => {
                    this.updateAnalysis();
                });

                // Set up UI control event listeners
                document.getElementById('unitSelect').addEventListener('change', () => {
                    this.updateAnalysis();
                });

                document.getElementById('startDate').addEventListener('change', () => {
                    this.onDateRangeChanged();
                });

                document.getElementById('endDate').addEventListener('change', () => {
                    this.onDateRangeChanged();
                });
            }

            // Handle when both datasets are loaded and ready
            onDataReady() {
                document.getElementById('uploadSection').classList.add('hidden');
                document.getElementById('analysisSection').classList.remove('hidden');
                
                this.initializeInterface();
            }

            // Initialize the analysis interface with default values
            initializeInterface() {
                this.uiManager.initializeMultiSelect();
                
                // Set default date range (last 2 years)
                const endDate = new Date();
                const startDate = new Date();
                startDate.setFullYear(endDate.getFullYear() - 2);
                
                document.getElementById('startDate').value = formatDate(startDate);
                document.getElementById('endDate').value = formatDate(endDate);

                this.onDateRangeChanged();
            }

            // Handle date range changes and update available companies
            onDateRangeChanged() {
                const startDate = new Date(document.getElementById('startDate').value);
                const endDate = new Date(document.getElementById('endDate').value);
                
                const dateChanged = this.dataManager.updateDateRange(startDate, endDate);
                if (dateChanged) {
                    this.equityCalculator.clearCache();
                    this.updateAvailableCompanies();
                    this.updateAnalysis();
                }
            }

            // Update list of available companies based on current data
            updateAvailableCompanies() {
                const companiesWithProduction = this.dataManager.getCompaniesWithProduction();
                this.eventBus.emit('companiesUpdated', { companies: companiesWithProduction });
            }

            // Main analysis function that processes data and updates charts
            updateAnalysis() {
                const selectedCompanies = this.uiManager.getSelectedCompanyIds();
                const selectedCompanyNames = this.uiManager.getSelectedCompanyNames();
                const unitSystem = document.getElementById('unitSelect').value;
                
                // Process production data
                const productionData = this.productionProcessor.processProductionData(selectedCompanies, unitSystem);
                
                // Update charts
                this.chartManager.updateCharts(
                    productionData, 
                    selectedCompanies, 
                    selectedCompanyNames, 
                    unitSystem, 
                    this.productionProcessor
                );
            }

            // File type detection based on column headers
            detectFileType(headers) {
                const productionColumns = ['prfYear', 'prfMonth', 'prfNpdidInformationCarrier', 'prfPrdOilNetMillSm3'];
                const licenseeColumns = ['fldNpdidField', 'cmpNpdidCompany', 'fldLicenseeFrom', 'fldLicenseeTo'];
                
                const hasProductionColumns = productionColumns.every(col => headers.includes(col));
                const hasLicenseeColumns = licenseeColumns.every(col => headers.includes(col));
                
                if (hasProductionColumns) return 'production';
                if (hasLicenseeColumns) return 'licensee';
                return 'unknown';
            }

            // Update pill status
            updatePillStatus(fileType, isLoaded) {
                const pillId = fileType === 'production' ? 'productionPill' : 'licenseePill';
                const pill = document.getElementById(pillId);
                
                if (isLoaded) {
                    pill.className = 'px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-700 border border-green-300';
                    pill.innerHTML = pill.innerHTML.replace('fa-file-csv', 'fa-check-circle');
                } else {
                    pill.className = 'px-3 py-1 rounded-full text-sm font-medium bg-gray-100 text-gray-600 border border-gray-300';
                    pill.innerHTML = pill.innerHTML.replace('fa-check-circle', 'fa-file-csv');
                }
            }

            // Add status message
            addStatusMessage(message, type = 'info') {
                const statusContainer = document.getElementById('uploadStatus');
                const statusDiv = document.createElement('div');
                
                let iconClass, textClass, bgClass, borderClass;
                switch (type) {
                    case 'success':
                        iconClass = 'fas fa-check-circle text-green-500';
                        textClass = 'text-green-700';
                        bgClass = 'bg-green-50';
                        borderClass = 'border-green-200';
                        break;
                    case 'error':
                        iconClass = 'fas fa-exclamation-circle text-red-500';
                        textClass = 'text-red-700';
                        bgClass = 'bg-red-50';
                        borderClass = 'border-red-200';
                        break;
                    case 'warning':
                        iconClass = 'fas fa-exclamation-triangle text-yellow-500';
                        textClass = 'text-yellow-700';
                        bgClass = 'bg-yellow-50';
                        borderClass = 'border-yellow-200';
                        break;
                    default:
                        iconClass = 'fas fa-info-circle text-blue-500';
                        textClass = 'text-blue-700';
                        bgClass = 'bg-blue-50';
                        borderClass = 'border-blue-200';
                }
                
                statusDiv.className = `flex items-center gap-2 p-3 rounded-md border ${bgClass} ${borderClass}`;
                statusDiv.innerHTML = `
                    <i class="${iconClass}"></i>
                    <span class="text-sm ${textClass}">${message}</span>
                    <button onclick="this.parentElement.remove()" class="ml-auto text-gray-400 hover:text-gray-600">
                        <i class="fas fa-times text-xs"></i>
                    </button>
                `;
                
                statusContainer.appendChild(statusDiv);
                
                // Auto-remove success messages after 5 seconds
                if (type === 'success') {
                    setTimeout(() => {
                        if (statusDiv.parentElement) {
                            statusDiv.remove();
                        }
                    }, 5000);
                }
            }

            // Clear status messages
            clearStatusMessages() {
                document.getElementById('uploadStatus').innerHTML = '';
            }

            // Initialize multi-file upload functionality
            initializeFileUploads() {
                const dropZone = document.getElementById('multiDropZone');
                const fileInput = document.getElementById('multiFileInput');

                dropZone.addEventListener('click', () => fileInput.click());
                
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('drag-over');
                });
                
                dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                    const files = Array.from(e.dataTransfer.files);
                    this.handleMultipleFiles(files);
                });
                
                fileInput.addEventListener('change', (e) => {
                    const files = Array.from(e.target.files);
                    this.handleMultipleFiles(files);
                });
            }

            // Handle multiple file uploads
            async handleMultipleFiles(files) {
                this.clearStatusMessages();
                
                if (files.length === 0) {
                    this.addStatusMessage('No files selected', 'warning');
                    return;
                }
                
                // Filter CSV files
                const csvFiles = files.filter(file => file.name.toLowerCase().endsWith('.csv'));
                const nonCsvFiles = files.filter(file => !file.name.toLowerCase().endsWith('.csv'));
                
                if (nonCsvFiles.length > 0) {
                    this.addStatusMessage(`Skipped ${nonCsvFiles.length} non-CSV file(s): ${nonCsvFiles.map(f => f.name).join(', ')}`, 'warning');
                }
                
                if (csvFiles.length === 0) {
                    this.addStatusMessage('No CSV files found in selection', 'error');
                    return;
                }
                
                this.addStatusMessage(`Processing ${csvFiles.length} CSV file(s)...`, 'info');
                
                // Process each CSV file
                for (const file of csvFiles) {
                    await this.processSingleFile(file);
                }
            }

            // Process a single CSV file
            async processSingleFile(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            const csvText = e.target.result;
                            const lines = csvText.trim().split('\n');
                            
                            if (lines.length < 2) {
                                this.addStatusMessage(`${file.name}: File appears to be empty or has no data rows`, 'error');
                                resolve();
                                return;
                            }
                            
                            // Parse headers
                            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                            
                            // Detect file type
                            const fileType = this.detectFileType(headers);
                            
                            if (fileType === 'unknown') {
                                this.addStatusMessage(`${file.name}: Could not determine file type from column headers. Expected production columns: prfYear, prfMonth, prfNpdidInformationCarrier, prfPrdOilNetMillSm3 OR licensee columns: fldNpdidField, cmpNpdidCompany, fldLicenseeFrom, fldLicenseeTo`, 'error');
                                resolve();
                                return;
                            }
                            
                            // Parse full data
                            const data = this.parseCSV(csvText);
                            
                            if (data.length === 0) {
                                this.addStatusMessage(`${file.name}: No valid data rows found`, 'error');
                                resolve();
                                return;
                            }
                            
                            // Load data based on type
                            if (fileType === 'production') {
                                if (this.dataManager.rawData.production) {
                                    this.addStatusMessage(`${file.name}: Production data already loaded, replacing previous data`, 'warning');
                                }
                                this.dataManager.loadProductionData(data);
                                this.updatePillStatus('production', true);
                                this.addStatusMessage(`${file.name}: Production data loaded successfully (${data.length} records)`, 'success');
                            } else if (fileType === 'licensee') {
                                if (this.dataManager.rawData.licensee) {
                                    this.addStatusMessage(`${file.name}: Licensee data already loaded, replacing previous data`, 'warning');
                                }
                                this.dataManager.loadLicenseeData(data);
                                this.updatePillStatus('licensee', true);
                                this.addStatusMessage(`${file.name}: Licensee data loaded successfully (${data.length} records)`, 'success');
                            }
                            
                        } catch (error) {
                            this.addStatusMessage(`${file.name}: Error parsing CSV - ${error.message}`, 'error');
                        }
                        
                        resolve();
                    };
                    
                    reader.onerror = () => {
                        this.addStatusMessage(`${file.name}: Error reading file`, 'error');
                        resolve();
                    };
                    
                    reader.readAsText(file);
                });
            }

            // Parse CSV text into array of objects
            parseCSV(text) {
                const lines = text.trim().split('\n');
                const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                const data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] ? values[index].trim().replace(/"/g, '') : '';
                    });
                    data.push(row);
                }
                return data;
            }

            // ===================================================================
            // DEBUG FUNCTION - Detailed analysis of equity calculations and production data
            // ===================================================================
            debugProduction(fieldId, companyId, year, month) {
                console.log('='.repeat(80));
                console.log(`DEBUG ANALYSIS: Field ${fieldId}, Company ${companyId}, ${year}-${month.toString().padStart(2, '0')}`);
                console.log('='.repeat(80));
                
                // Validate inputs
                if (!this.dataManager.isDataReady()) {
                    console.log(' ERROR: Data not loaded yet');
                    return;
                }
                
                const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                const targetDate = new Date(year, month - 1, 1);
                
                // Get field and company names
                const fieldName = this.dataManager.getFieldName(fieldId);
                const companyName = this.dataManager.getCompanyName(companyId);
                
                console.log(` Field: ${fieldName || 'UNKNOWN'} (ID: ${fieldId})`);
                console.log(` Company: ${companyName || 'UNKNOWN'} (ID: ${companyId})`);
                console.log(` Target Date: ${targetDate.toDateString()} (${monthKey})`);
                console.log(` Current Date Range: ${formatDate(this.dataManager.currentDateRange.startDate)} to ${formatDate(this.dataManager.currentDateRange.endDate)}`);
                
                // Check if target month is in current filtered range
                const isInRange = isDateInRange(targetDate, this.dataManager.currentDateRange.startDate, this.dataManager.currentDateRange.endDate);
                console.log(` Month in filtered range: ${isInRange}`);
                
                if (!isInRange) {
                    console.log('  WARNING: Target month is outside current date filter range');
                }
                
                console.log('\n' + ''.repeat(60));
                console.log('LICENSE ANALYSIS');
                console.log(''.repeat(60));
                
                // Get all licenses for this field/company combination
                const licenses = this.dataManager.getLicensesForFieldCompany(fieldId, companyId);
                console.log(` Found ${licenses.length} license(s) for this field/company combination:`);
                
                if (licenses.length === 0) {
                    console.log(' No licenses found - company has no stake in this field');
                    return;
                }
                
                let totalEquity = 0;
                let activeLicenseCount = 0;
                
                licenses.forEach((license, index) => {
                    console.log(`\n License ${index + 1}:`);
                    console.log(`   Company Share: ${license.fldCompanyShare}%`);
                    console.log(`   SDFI Share: ${license.fldSdfiShare}% ${license.fldSdfiShare === '' ? '(defaulting to 100%)' : ''}`);
                    console.log(`   License From: ${license.fldLicenseeFrom || 'N/A'}`);
                    console.log(`   License To: ${license.fldLicenseeTo || 'N/A'}`);
                    
                    // Parse license dates
                    const fromDate = parseLicenseDate(license.fldLicenseeFrom) || new Date('1900-01-01');
                    const toDate = parseLicenseDate(license.fldLicenseeTo) || new Date('2099-12-31');
                    
                    console.log(`   Parsed From: ${fromDate.toDateString()}`);
                    console.log(`   Parsed To: ${toDate.toDateString()}`);
                    
                    // Check if license is active for target month
                    const isActive = this.dataManager.isLicenseActiveForDate(license, targetDate);
                    console.log(`    Active for ${monthKey}: ${isActive}`);
                    
                    if (isActive) {
                        activeLicenseCount++;
                        const licenseEquity = this.equityCalculator.calculateLicenseEquity(license.fldCompanyShare, license.fldSdfiShare);
                        totalEquity += licenseEquity;
                        
                        console.log(`    License Equity Calculation:`);
                        console.log(`      (${license.fldCompanyShare || 0}/100)  (${license.fldSdfiShare || 100}/100) = ${licenseEquity.toFixed(6)}`);
                    } else {
                        console.log(`    License not active - outside date range`);
                    }
                });
                
                console.log(`\n TOTAL COMPANY EQUITY: ${totalEquity.toFixed(6)} (${(totalEquity * 100).toFixed(4)}%)`);
                console.log(` Active Licenses: ${activeLicenseCount}/${licenses.length}`);
                
                // Compare with cached calculation
                const cachedEquity = this.equityCalculator.getCompanyEquity(fieldId, monthKey, companyId);
                console.log(` Cached Equity: ${cachedEquity.toFixed(6)}`);
                console.log(` Calculation Match: ${Math.abs(totalEquity - cachedEquity) < 0.000001}`);
                
                console.log('\n' + ''.repeat(60));
                console.log('PRODUCTION ANALYSIS');
                console.log(''.repeat(60));
                
                // Get production data for this field/month
                const productionRow = this.dataManager.getProductionForFieldMonth(fieldId, monthKey);
                
                if (!productionRow) {
                    console.log(` No production data found for ${fieldName} in ${monthKey}`);
                    return;
                }
                
                console.log(` Production Data for ${monthKey}:`);
                console.log(`   Oil: ${productionRow.prfPrdOilNetMillSm3} million m`);
                console.log(`   Gas: ${productionRow.prfPrdGasNetBillSm3} billion m`);
                console.log(`   NGL: ${productionRow.prfPrdNGLNetMillSm3} million m`);
                console.log(`   Condensate: ${productionRow.prfPrdCondensateNetMillSm3} million m`);
                
                // Calculate oil equivalent
                const oilEquivalent = (parseFloat(productionRow.prfPrdOilNetMillSm3) || 0) + 
                                     (parseFloat(productionRow.prfPrdGasNetBillSm3) || 0) + 
                                     (parseFloat(productionRow.prfPrdNGLNetMillSm3) || 0) + 
                                     (parseFloat(productionRow.prfPrdCondensateNetMillSm3) || 0);
                
                console.log(`   Oil Equivalent: ${oilEquivalent} million m`);
                
                console.log('\n' + ''.repeat(60));
                console.log('COMPANY PRODUCTION SHARE CALCULATION');
                console.log(''.repeat(60));
                
                if (totalEquity > 0) {
                    console.log(` Company's Share Calculation:`);
                    
                    CONFIG.RESOURCE_TYPES.forEach(resourceType => {
                        const rawProduction = this.productionProcessor.getResourceProduction(productionRow, resourceType.key);
                        const companyShare = rawProduction * totalEquity;
                        
                        console.log(`\n ${resourceType.name}:`);
                        console.log(`   Field Total: ${rawProduction.toFixed(6)} million m`);
                        console.log(`   Company Equity: ${(totalEquity * 100).toFixed(4)}%`);
                        console.log(`   Company Share: ${rawProduction.toFixed(6)}  ${totalEquity.toFixed(6)} = ${companyShare.toFixed(6)} million m`);
                        
                        // Show unit conversions
                        const year = parseInt(productionRow.prfYear);
                        const month = parseInt(productionRow.prfMonth);
                        
                        ['si-monthly', 'si-daily', 'barrels-daily'].forEach(unitSystem => {
                            const converted = this.productionProcessor.convertProduction(companyShare, resourceType.key, unitSystem, year, month);
                            const unit = this.productionProcessor.getUnitLabel(resourceType.key, unitSystem);
                            console.log(`   ${unitSystem}: ${converted.toFixed(2)} ${unit}`);
                        });
                    });
                } else {
                    console.log(` No equity - company has no production share in this field for ${monthKey}`);
                }
                
                console.log('\n' + ''.repeat(60));
                console.log('RELATIONSHIP VALIDATION');
                console.log(''.repeat(60));
                
                // Check field-company relationships
                const fieldCompanies = this.dataManager.indices.fieldCompanies.get(fieldId);
                const companyFields = this.dataManager.indices.companyFields.get(companyId);
                
                console.log(` Companies in this field: ${fieldCompanies ? Array.from(fieldCompanies).length : 0}`);
                console.log(` Fields for this company: ${companyFields ? Array.from(companyFields).length : 0}`);
                console.log(` Relationship exists: ${fieldCompanies?.has(companyId) || false}`);
                
                if (fieldCompanies) {
                    console.log(` All companies in ${fieldName}:`);
                    Array.from(fieldCompanies).forEach(cId => {
                        const cName = this.dataManager.getCompanyName(cId);
                        const equity = this.equityCalculator.getCompanyEquity(fieldId, monthKey, cId);
                        console.log(`   ${cName} (${cId}): ${(equity * 100).toFixed(4)}%`);
                    });
                }
                
                console.log('\n' + ''.repeat(60));
                console.log('CACHE STATUS');
                console.log(''.repeat(60));
                
                const cacheKey = `${fieldId}|${monthKey}|${companyId}`;
                const isCached = this.equityCalculator.equityCache.has(cacheKey);
                console.log(` Equity cached: ${isCached}`);
                console.log(` Total cache entries: ${this.equityCalculator.equityCache.size}`);
                
                console.log('\n' + '='.repeat(80));
                console.log('DEBUG ANALYSIS COMPLETE');
                console.log('='.repeat(80));
            }
        }

        // ===================================================================
        // APPLICATION INITIALIZATION
        // ===================================================================

        // Create global app instance and expose UI manager for onclick handlers
        window.app = new ProductionAnalysisApp();
        window.uiManager = window.app.uiManager;
        window.chartManager = window.app.chartManager;
        window.debugProduction = (fieldId, companyId, year, month) => {
            return window.app.debugProduction(fieldId, companyId, year, month);
        };
    </script>
</body>
</html>
